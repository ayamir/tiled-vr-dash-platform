<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebXR with THREE.js</title>
</head>
<body>
<main style="text-align: center">
    <video id="baseVideo"></video>
</main>
<script src="./js/three.js"></script>
<script src="./js/dash/dash.all.min.js"></script>
<script src="./js/dash/mediasync.js"></script>
<script src="./js/dash/timingsrc-v2.js"></script>
<!-- WebGL -->
<script src="./js/webgl/webgl-utils.js"></script>
<script src="./js/webgl/m4.js"></script>
<script id="drawImage-vertex-shader" type="x-shader/x-vertex">
    attribute vec4 a_position;
    attribute vec2 a_texcoord;

    uniform mat4 u_matrix;
    varying vec2 v_texcoord;

    void main() {
        gl_Position = u_matrix * a_position;
        v_texcoord = a_texcoord;
    }
</script>
<script id="drawImage-fragment-shader" type="x-shader/x-fragment">
    precision mediump float;
    varying vec2 v_texcoord;
    uniform sampler2D u_texture;

    void main() {
        gl_FragColor = texture2D(u_texture, v_texcoord);
    }
</script>
<script type="module">
	import {WebXRButton} from "./js/util/webxr-button.js";
	import {mat4, vec3} from "./js/matrix/index.js";
	import {MenuSystem} from "./js/render/nodes/menu-system.js";

	const {XRRigidTransform} = window;

	let videoTexture = null;
	let radius = 0;
	let rows = 0;
	let cols = 0;
	let baseUrl = null;
	let urls = null;
	let baseVideo = null;
	let baseDash = null;
	let baseWidth = 0;
	let baseHeight = 0;
	let tileWidth = 0;
	let tileHeight = 0;

	let isReady = [];
	let isSelected = [];
	let enhanceVideos = [];
	let enhanceDash = [];
	let videoMediaSync = [];
	let timingSyncSrc = null;

	let fov = 100;
	let width = 0;
	let height = 0;
	let aspect = 1;
	let near = 0.1;
	let far = 1000;

	let position = {
		x: 0, y: 0, z: 10
	};
	let target = {
		x: 0, y: 0, z: 0
	}

	let gl = null;
	let canvas = null;
	let container = null;
	let xrButton = null;
	let xrSession = null;
	let xrRefSpace = null;
	let preferredXRSpace = "local";
	let preferredFeature = "local";

	let scene = null;
	let camera = null;
	let renderer = null;
	let texture = null;
	let geometry1 = null;
	let geometry2 = null;
	let material1 = null;
	let material2 = null;
	let mesh1 = null;
	let mesh2 = null;

	function initTexture() {
		const texture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture);

		const level = 0;
		const internalFormat = gl.RGBA;
		const width = 1;
		const height = 1;
		const border = 0;
		const srcFormat = gl.RGBA;
		const srcType = gl.UNSIGNED_BYTE;
		const pixel = new Uint8Array([0, 0, 255, 255]);
		gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, srcFormat, srcType, pixel);

		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

		return texture;
	}

	function updateTexture(texture, video) {
		const level = 0;
		const internalFormat = gl.RGBA;
		const srcFormat = gl.RGBA;
		const srcType = gl.UNSIGNED_BYTE;
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, srcFormat, srcType, video);
	}

	function drawImage(tex, texWidth, texHeight, dstX, dstY) {
		let program = webglUtils.createProgramFromScripts(
			gl, ["drawImage-vertex-shader", "drawImage-fragment-shader"]
		);
		let positionLocation = gl.getAttribLocation(program, "a_position");
		let texcoordLocation = gl.getAttribLocation(program, "a_texcoord");

		let matrixLocation = gl.getUniformLocation(program, "u_matrix");
		let textureLocation = gl.getUniformLocation(program, "u_texture");

		let positionBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
		let positions = [
			0, 0,
			0, 1,
			1, 0,
			1, 0,
			0, 1,
			1, 1,
		];
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

		let texcoordBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
		let texcoords = [
			0, 0,
			0, 1,
			1, 0,
			1, 0,
			0, 1,
			1, 1,
		];
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texcoords), gl.STATIC_DRAW);
		gl.bindTexture(gl.TEXTURE_2D, tex);

		// tell webgl to use program
		gl.useProgram(program);

		// pull data from buffer
		gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
		gl.enableVertexAttribArray(positionLocation);
		gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
		gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
		gl.enableVertexAttribArray(texcoordLocation);
		gl.vertexAttribPointer(texcoordLocation, 2, gl.FLOAT, false, 0, 0);

		// convert matrix from pixels to clip space
		let matrix = m4.orthographic(0, gl.canvas.width, gl.canvas.height, 0, -1, 1);

		// translate quad to dstX, dstY
		matrix = m4.translate(matrix, dstX, dstY, 0);
		matrix = m4.scale(matrix, texWidth, texHeight);
		gl.uniformMatrix4fv(matrixLocation, false, matrix);
		gl.uniform1i(textureLocation, 0);
		gl.drawArrays(gl.TRIANGLES, 0, 6);
	}

	function myFetch(source) {
		return fetch(source).then((response) => {
			return response.json();
		});
	}

	function onResize() {
		width = window.innerWidth;
		height = window.innerHeight;
		aspect = width / height;

		if (renderer) {
			renderer.setSize(width, height);
		}
		if (camera) {
			camera.aspect = aspect;
			camera.updateProjectionMatrix();
		}
	}

	async function initXR() {
		onResize();
		window.addEventListener("resize", onResize);

		let data = await myFetch("./source.json");
		radius = data.radius;
		rows = data.rows;
		cols = data.cols;
		urls = data.urls;
		baseUrl = data.baseUrl;
		baseWidth = data.baseWidth;
		baseHeight = data.baseHeight;
		tileWidth = data.tileWidth;
		tileHeight = data.tileHeight;

		xrButton = new WebXRButton({
			onEndSession: onEndSession,
			onRequestSession: onRequestSession,
		})
		container = document.querySelector("main");
		container.appendChild(xrButton.domElement);

		if (navigator.xr) {
			navigator.xr.isSessionSupported("immersive-vr").then((supported) => {
				xrButton.enabled = supported;
			});
		}
	}

	function onEndSession() {
		if (xrSession) {
			xrSession.end();
		}
	}

	function onRequestSession() {
		if (!xrSession) {
			navigator.xr.requestSession("immersive-vr", {
				optionalFeatures: ["local-floor", "bounded-floor"],
			}).then(onSessionStarted);
		} else {
			onEndSession();
		}
	}

	async function onSessionStarted(session) {
		xrSession = session;
		session.addEventListener("end", onEndSession);

		// init baseVideo
		baseVideo = document.getElementById("baseVideo");
		baseDash = dashjs.MediaPlayer().create();
		baseDash.initialize(baseVideo, baseUrl, true);
		baseDash.updateSettings({
			fastSwitchEnabled: true, // 黑块率较高的清空下，基础流也是需要提升质量的
			stableBufferTime: 30, // buffer尽可能的长
			bufferTimeAtTopQuality: 60, // 最高质量不用担心rebuffer，所以可以尽可能的给较长的buffer
			bufferTimeAtTopQualityLongForm: 120,
			longFormContentDurationThreshold: 200
		});
		baseVideo.load();
		await baseVideo.play();
		timingSyncSrc = new TIMINGSRC.TimingObject({
			position: baseVideo.currentTime
		});

		// init enhanced layers
		for (let i = 0; i < rows * cols; i++) {
			isReady.push(false);
			isSelected.push(false);
			enhanceVideos.push(null);
			enhanceDash.push(null);
			videoMediaSync.push(null);
		}

		// init canvas
		canvas = document.createElement("canvas");
		canvas.width = baseWidth;
		canvas.height = baseHeight;
		canvas.style.width = baseWidth / 2 + "px";
		canvas.style.height = baseHeight / 2 + "px";
		container.appendChild(canvas);

		// init ctx
		gl = canvas.getContext("webgl2");

		// init renderer
		renderer = new THREE.WebGLRenderer({antialias: true, context: gl});
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setSize(width, height);
		renderer.xr.enabled = true;
		renderer.xr.setReferenceSpaceType(preferredXRSpace);
		await renderer.xr.setSession(session);
		renderer.sortObjects = false;
		renderer.autoClear = false;
		container.appendChild(renderer.domElement);

		// init camera
		camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
		camera.position.set(position.x, position.y, position.z);
		camera.target = new THREE.Vector3(target.x, target.y, target.z);

		// init scene
		scene = new THREE.Scene();
		scene.add(camera);

		// init texture
		texture = new THREE.VideoTexture({
            video: baseVideo,
            mapping: THREE.EquirectangularReflectionMapping
		});

		// init geometry
		geometry1 = new THREE.SphereGeometry(radius, 80, 40);
		geometry2 = new THREE.SphereGeometry(radius, 80, 40);
		geometry1.scale(-1, 1, 1);
		geometry2.scale(-1, 1, 1);
		const uvs1 = geometry1.attributes.uv.array;
		for (let i = 0; i < uvs1.length; i += 2) {
			uvs1[i] *= 0.5;
		}
		const uvs2 = geometry2.attributes.uv.array;
		for (let i = 0; i < uvs2.length; i += 2) {
			uvs2[i] *= 0.5;
			uvs2[i] += 0.5;
		}

		// init mesh
		material1 = new THREE.MeshBasicMaterial({map: texture});
		mesh1 = new THREE.Mesh(geometry1, material1);
		mesh1.rotation.y = -Math.PI / 2;
		mesh1.layers.set(1);
		scene.add(mesh1);

		material2 = new THREE.MeshBasicMaterial({map: texture});
		mesh2 = new THREE.Mesh(geometry2, material2);
		mesh2.rotation.y = -Math.PI / 2;
		mesh2.layers.set(2);
		scene.add(mesh2);

		await renderer.getContext().makeXRCompatible();
		renderer.domElement.hidden = false;

		let layer = new XRWebGLLayer(xrSession, gl);
		xrSession.updateRenderState({baseLayer: layer});

		session.requestAnimationFrame(onXRFrame);
	}

	function updateInput(frame) {
        
	}

	function onXRFrame(time, frame) {
		let pose = frame.getViewerPose(xrRefSpace);
		xrSession.requestAnimationFrame(onXRFrame);

		camera.matrixAutoUpdate = false;
		renderer.autoClear = false;

		if (pose) {
			let xrLayer = xrSession.renderState.baseLayer;
			updateInput(frame);
			gl.bindFramebuffer(gl.FRAMEBUFFER, xrLayer.framebuffer);
			gl.clearColor(0, 0, 0, 1.0);
			gl.clearDepth(1.0);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			for (let view of pose.views) {
                let viewport = xrLayer.getViewport(view);
				renderer.setViewport(viewport.x, viewport.y, viewport.width, viewport.height);
				const viewMatrix = view.transform.inverse.matrix;
				camera.projectionMatrix.fromArray(view.projectionMatrix);
				camera.matrix.fromArray(viewMatrix).copy(camera.matrix).invert();
				camera.updateMatrixWorld(true);
			}
		}
		renderer.render(scene, camera);
	}

	initXR();
</script>

</body>
</html>